# EmberCamp Chicago 2019

* September 16th, 2019
* Master of Ceremonies: [Trek Glowacki](https://twitter.com/trek)

## Don’t Just Put a `<div>`input On It—Use the Power of the Browser!

* Speaker: __[Marie Chatfield](https://twitter.com/mariechatfield)__ ([GitHub](https://github.com/mariechatfield))
* __[Slides](https://drive.google.com/file/d/1oRF9lvjEyWTAcmWW0THLmcdM95nate1x/view)__
* __[Blog](http://mariechatfield.com/blog/semantic-html)__

#### Synopsis

The humble `<div>` is a powerful and flexible element. Throw enough CSS and JavaScript on it, and a can be anything. 
But should it be? “Semantic HTML” is a method of using elements that best match what your content means and does. 
But how do you write better markup if you don’t know your options? Join the learning journey to fill your semantic HTML toolkit with the coolest elements you never knew existed. Learn specific elements to use in different scenarios and how to wield the full power of the HTML spec. You’ll write less code while making your pages more accessible and mobile-friendly!

#### Bio

Marie writes code and poetry, sometimes at the same time. As a front-end engineering enthusiast, she’s currently helping the fine folks at Pingboard build the world’s best org chart software. She is passionate about creating inclusive experiences and understanding foundational web technologies at a deeper level. Talk to her about rock climbing or Texas!

### Notes

* Semantic HTML: Choosing elements based on their meaning
* Non-Semantic HTML: Choosing elements based on browser styles and/or using `<div>` for everything
* Keeps readable layout even if styles are missing or JavaScript is disabled
* Page is still functional (e.g. forms can submit)
* Improves accessibility
* More context with less code
* Why _Not_ Semantic HTML?
  * Element not supported across browsers
  * Specific UX/UI needs
  * You are willing to implement, test, and ensure accessibility of custom alternative
    * Does a library already exist, can I contribute?
    * Accessible?
    * Browser compatibility?
    * Mobile devices?
    * How hard is it to test & maintain?

##### Semantic Elements

* `<main>`
* `<article>`
* `<section>`
* `<aside>`
* `<nav>`
* `<header>`
* `<footer>`
* `<forms>`
* `<fieldset>`
* `<legend>`
* `<input>`
  * Supports many different types -
  * Basic: checkbox, number, radio, range, text
  * Formatted: email, tel, url
  * Date/Time: date, datetime-local, month, time, week
  * Form Controls: button, hidden, image, reset, submit
  * Special: color, file, password, search
* `<select>`
* `<option>`
* `<optgroup>`
* `<output>`
  * Unsupported by IE (won't break the site, just won't give you aria stuff)
* `<figure>`
* `<figcaption>`
* `<video>`
  * Format support varies by browser
* `<track>`
  * enables captions within `<video>`
* `<audio>`
  * Most browsers don't support `<track>` inside this element, but if you put `<audio>` inside `<video>`, it can work
* Text Formatting
  * `<pre>`
  * `<code>`
    * Executable code
  * `<samp>`
    * Terminal output
  * `<kbd>`
    * Keyboard imput
  * `<var>`
  * `<q>`
    * Most browsers will add the quotation marks
  * `<blockquote>`
    * Indented section
  * `<cite>`
    * Italicizes its content
  * `<abbr>`
  * `<dfn>`
  * `<address>`
  * `<time>`

## Build One Get Two --- Guide For When To Leverage Corber

* Speaker: __[Sean Devine](https://twitter.com/barelyknown)__ ([GitHub](https://github.com/barelyknown))

#### Bio

Sean Devine is the proud father of 5 children, a lucky husband to his amazing wife Theresa, an active Ember/JavaScript (and Rails/Ruby) developer, and the Founder and CEO of XBE - a Construction Logistics business based in Chicago, IL. He is thankful every day that he bet his company on Ember, and is more excited than ever about where things headed. When not working, or parenting, or programming, Sean enjoys running, cycling, and the NBA.

### Notes

> "Unless you have a large and sustainable development budget and are competing in a market where the user is the buyer and there is significant competition with feature parity, a hybrid mobile-first app is almost certainly your best option."

Conclusion: Almost everyone should be using [EmberJS](https://emberjs.com) and [Corber](http://corber.io/)!

How did XBE decide on their tech stack?

* Situation
  * People often have opinions about tech stacks without knowing any context the app will be built in
  * Diverse User Base
  * Broad & Deep Functionality
  * Bootstrapped, Small Team
  * Location-Centric Requirements
  * User/Buyer Dichotomy
  * Compulsory Usage
* Objective
  * Maximize: Leverage
  * Constraint: Location Tracking Requirement
  * Constraint: Bootstrapped Budget
* Options
  * Mobile-first web app with native tracking apps 
    * Viable
  * Hybrid mobile-first app
    * Viable
  * Multiple "native" apps with feature parity
    * Shockingly, this is the default choice of most companies
      * Featuresets almost never stay in sync across platforms
    * Non-viable: Too expensive
      * Larger/venture-backed companies can trick themselves into thinking this option is best b/c cost isn't a constraint
  * Mobile web only
    * Non-viable: Inadequate location tracking
* Decision
  * Mobile-first
  * Web-first
  * Responsible design
  * ??? (missed a fourth point in the slides - please add)
* Development
  * Build an app that "feels" right on a phone is the biggest challenge
  * Corber config and build process feels opaque and magical
  * Native app release process is cumbersome and manual
  * ___If you build a solid mobile-first web app with Ember, the native apps come for free___
* Missed Slide ???
* Implications
  * Know your situation and objective
  * Accept your constraints
  * Understand options in terms of your context
* _Maturity: Accepting What Is True And Acting Accordingly_
  
Note: This talk had lots of fun asphalt-related trivia not captured here.

## Worker Power!

* Speaker: __[Dan Gebhardt](https://twitter.com/dgeb)__ ([GitHub](https://github.com/dgeb))
* [Resources](http://bit.ly/ember-workers)

#### Synopsis

Web workers bring a new layer of capabilities to web applications. Because workers operate on their own threads, they provide a way to perform processor-intensive tasks without affecting the responsiveness of an application. This talk will explore the different types of workers, including service workers and shared workers, and how to make the most of them in your Ember applications. We'll discuss the capabilities available to workers and explore different use cases, including progressive web apps.

#### Bio

Dan is on the Ember.js core team, an editor of the JSON:API spec, and the creator of Orbit.js. He consults through Cerebris, the company he co-founded, and their partner Tilde. He loves to travel and hike with his family and fluffy dog.

### Notes

"This really is a talk about the power of organized labor"

* Web Workers
  * Dedicated
  * Shared
  * Service
* Main Thread: All processing done on the web happens here by default
* Workers are the only threading primitive on the web
  * Offload processing work to workers so that it can occur in parallel
* "Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once." - Rob Pike (Go Creator)
* What happens when we exceed the limits of concurrency on the main thread? __Jank.__
  * Things seem off when apps drop below 60 fps, meaning browsers need to repaint every 15 ms
* Perceived challenges to using workers
  * New and unproven? No, they've been around since 2012
  * Lack of browser support? No, widely supported by browsers
  * Lack of capabilities? No, give access to nearly every browser API
* Real challenges to using workers
  * Awkward to use
  * Awkward to test
  * Lack of FE framework support
  * All challenges are developer experience problems
* Characteristics of all workers
  * Async communication
  * No shared memory
  * Controlled lifetime
  * Access to browsers APIs
  * No direct access to DOM
* Dedicated Workers
  * Global browser support: High 90s percentile, even IE/Edge
  * Supports ES modules
  * Demo: Calculate fibonacci sequence of numbers in worker so that UI is not blocked
* Shared Workers
  * ~36% global browser availability: Not yet supported in safari/edge/IE
  * MessagePort
  * Same demo, running in multiple browser windows
    * Data synced across window via the shared worker
    * Each window has its own store, but they're communicating via shared memory of the worker
    * Built with OrbitJS & EmberJS
* Service Workers
  * Popular for building complete offline experiences
  * Global browser support: High 90s percentile, no IE support
  * Progressive Web App (PWA) Checklist
    * Site is served over HTTPs
    * Responsive
    * ??? More items (please add)
  * Can even customize response to `fetch`
* DX Improvements
  * __ember-workers__ (Upcoming addon!)
    * Uses rollup under the hood for tree-shaking, ES module support across all browsers, etc
    * Makes workers accessible everywhere
  * [promise-worker](https://github.com/nolanlawson/promise-worker)
    * Problem: Evented async can get awkward
    * This NPM package wraps Evented code in promise syntax for async/await
  * testing
    * Write modular code
    * Unit test your modules (w/o workers)
    * Stub workers in your tests
    * [worker-box](https://github.com/trentmwillis/worker-box)
      * Toolbox for stubbing web workers
      * More info: https://www.youtube.com/watch?v=JBnNp8MpRSM

## Compiling Ember

* Speaker: __[Ed Faulkner](https://twitter.com/eaf4)__ ([GitHub](https://github.com/ef4))

#### Synopsis

Compilers have a reputation for being esoteric and intimidating. But they don't need to be! A compiler is just a program that writes programs. This talk will be a practical tour through the Embroider build system that also teaches compiler concepts along the way. With the power of multi-pass compilation, Embroider can take a long-lived, conventional Ember app and give it lazy loading, code splitting, and tree shaking. All without modifying the app's own code.

#### Bio

Ed is a member of the Ember Framework core team. His open source code is running on mainstream gaming consoles, major social media sites, and hordes of enterprise applications. His consultancy, Polynomial LLC, leads ambitious software projects for a diverse group of businesses and nonprofits, and he is a lead developer for the Cardstack Project. https://cardstack.com

### Notes

* A compiler is a program
  * All programs have an input and output
  * A compiler's input _and_ output are both programs
    * Input: Language A, Output: Language B
    * Input is often easier for humans to read, output is often easier for machines to read
      * Decompiler swaps these
  * ??? Another compiler type (please add)
  * Transpiler: Input/Output are very similar
* Static: Facts you can know about a program before you run it
* Dynamic: Facts you cannot know about a program before you run it
* Compiled preserve the semantics of the input language to produce the same output in the resulting program
* Often the input language cannot produce an output itself without being compiled first
  * Example: Ember app compiles to `dist/**`, browser cannot run the Ember app itself
  * Conceptually, however, your app has both an input and an output, regardless of the implementation details
* __Implementor's Trap: Neglecting the abstract semantics of your language, because you know "how it really works".__
* Does Ember have clear abstract semantics? _Overwhelmingly, yes!_
  * Follows standards
  * APIs are implemented very carefully
  * One area in particular needs improvement: Modules
  * Ember has been rewritten into modules over time, but we're not all the way there yet
* ModuleSpecifier
  * ECMA spec leaves this up to implementation, not codified by JavaScript the language
* Module imports must be known before program is run
  * No dynamic names for imported files
  * No conditional imports
  * Everything about `import` is designed to be static
  * For dynamic things, there's `import()`
* RFC: [V2 Addon Format (Embroider compatibility)](https://github.com/emberjs/rfcs/pull/507)
  * This RFC defines a new package format that is designed to make Ember packages (meaning both apps and addons) statically analyzable and more compatible with the rest of the NPM & Javascript ecosystem. This RFC is the first step in stabilizing [Embroider](https://github.com/embroider-build/embroider) as our next-generation build system.
* Embroider: Multi-Stage Compiler
  * Takes multiple intermediate compilation steps before final output is generated
  * Allows you to simplify the input over time so that very powerful low-level optimizations become possible in the final output
  * Target a well-documented, stable shared solution language instead of trying to compile all the way to what the machine will read
  * Workflow: Ember App & Addons -> `@embroider/compat` -> V2 Ember Packages -> `@embroider/core` -> Plain JS/CSS/HTML -> `@embroider/webpack` -> Browser-optimized JS/CSS/HTML
* Stage 1: Compat
  * Runs custom broccoli trees
  * Moves files so they match their import paths
  * Recaptures modules that try to escape their package
  * Applies custom preprocessors
  * Generates `@embroider/synthesized-vendor` package to represent legacy non-package-scoped contents as a v2 package
* Stage 2: Core
  * Synthesizes JavaScript entrypoints that `import` the required modules to boot the app
  * Resolves components and helpers and emites ` import` statements for them at the top of each compiled template module
  * Uses dynamic `import()` to express potential split points like routes and lazy engines
* Stage 3: Optimized Packaging
  * Delegate to a standard JavaScript build tool
    * Could be rollup, parcel, etc
    * Flexibility to choose future tools that haven't even been written yet!
  * Give it total freedom to decide how our entire module graph should be optimized for web delivery
* Benefits
  * Complete pull-based builds
  * Faster builds
  * Use dynamic `import()` anywhere for arbitrary code splitting and lazy loading
  * Automated route-aware code splitting
  * Import anything directly from NPM, statically or dynamically
    * `[ember-auto-import](https://github.com/ef4/ember-auto-import)` is a polyfill for Embroider's third-party package import, but it doesn't work with Ember code
* __Keep moving forward. No big app rewrites. Ember <3__

## Steady State With Ember Octane

* Speaker: __[Jessica Jordan](https://twitter.com/jjordan_dev)__ ([GitHub](https://github.com/jessica-jordan))

#### Synopsis

Ever wondered where your component state went or where it came from? ​​In this talk you will learn how arguments, decorators and tracked properties make state management of your component built in Ember Octane easier than ever before. In comparison with patterns known from traditional Ember apps, you will learn how to transform your modern components to predictable and future-proof building blocks of your application.

#### Bio

Jessica is a member of the Ember Learning Core team and a software engineer at simplabs. She is an editor at The Ember Times and organizes the Ember Berlin meetup. She is passionate about open-source, CSS, art and comics.

## Navigating Towards Stronger App Architecture Using Maps

* Speaker: __Matt Gardner__

## Content Choreography: Meaningful Motion In Ember Apps

* Speaker: __James Steinbach__

## May I Ask a Question, Live!

* Speakers: __Jen Weber__ & __Preston Sego__

## Mocks, Spices, and Timers - Oh My!

* Speaker: __Lisa Backer__

## Modifiers: the Good and the Camp

* Speaker: __Spencer Price__

## Keynote: Redefining Risk Taking

* Speaker: __Olivia Liddell__

## Closing Comments

* Speakers: __Melanie Sumner__ & __Sean Massa__
